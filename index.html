<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERD Viewer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background-color: #f4f4f9;
        }

        #sidebar {
            width: 250px;
            background-color: #fff;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        #main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #toolbar {
            padding: 10px;
            background-color: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        #toolbar-left {
            margin-right: auto;
            font-size: 14px;
            color: #666;
        }

        /* 공통 버튼 스타일 */
        .toolbar-btn {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: all 0.2s;
            font-weight: 600;
        }
        
        /* 중립적 버튼 (확대/축소) */
        .neutral-btn {
            background-color: #e5e7eb; /* gray-200 */
            color: #4b5563; /* gray-700 */
        }
        .neutral-btn:hover {
            background-color: #d1d5db; /* gray-300 */
        }

        /* 강조 버튼 (저장) */
        .primary-btn {
            background-color: #3b82f6; /* blue-500 */
            color: #fff;
        }
        .primary-btn:hover {
            background-color: #2563eb; /* blue-600 */
        }

        #erd-container {
            flex-grow: 1;
            padding: 20px;
            position: relative;
            background-color: #fff;
            /* Changed from 'hidden' to 'auto' to enable scrollbars */
            overflow: auto; 
        }

        /* erd-canvas와 link-canvas를 담는 새로운 컨테이너 */
        #pan-container {
            position: relative; /* Changed from absolute */
            transform-origin: 0 0;
            cursor: grab;
        }
        
        #link-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        #erd-canvas {
            position: relative; /* Changed from absolute */
            min-width: 100%; /* Ensure canvas takes at least full width */
            min-height: 100%; /* Ensure canvas takes at least full height */
            cursor: default;
            z-index: 2;
        }

        .table-box {
            border: 1px solid #333;
            background-color: #f9f9f9;
            padding: 10px;
            margin: 10px;
            display: inline-block;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            position: absolute;
            cursor: move;
            transform-origin: 0 0;
        }
        
        .table-box h4 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #ccc;
            color: #3b82f6; /* Changed to a Tailwind-like blue */
            font-weight: bold;
        }

        .table-box table {
            width: 100%;
            border-collapse: collapse;
        }

        .table-box th,
        .table-box td {
            border: 1px solid #3a3838;
            padding: 5px;
            text-align: left;
            font-size: 12px;
        }

        .table-box th {
            background-color: #93c5fd; /* Changed to a Tailwind-like blue */
        }

        .pk-row td:first-child {
            font-weight: bold;
            color: #ef4444; /* Changed to a Tailwind-like red */
        }

        .fk-row td:first-child {
            font-weight: bold;
            color: #3b82f6; /* Changed to a Tailwind-like blue */
        }

        .link-line {
            stroke: #888;
            stroke-width: 2;
        }

        .link-head {
            fill: #888;
        }

        /* Custom Modal Styling */
        .modal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 24px;
            border: 1px solid #ccc;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 2000;
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            color: #333;
            animation: fadein 0.3s ease-out;
        }

        @keyframes fadein {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to   { opacity: 1; transform: translate(-50%, -50%); }
        }

        .modal.fadeout {
            animation: fadeout 0.3s ease-in forwards;
        }

        @keyframes fadeout {
            from { opacity: 1; transform: translate(-50%, -50%); }
            to   { opacity: 0; transform: translate(-50%, -60%); }
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h3>Databases</h3>
        <select id="schema-select" class="w-full p-2 border border-gray-300 rounded-lg" onchange="loadTables(this.value)">
            <option value="">Select a database</option>
        </select>
        <h3>Tables</h3>
        <p class="text-sm text-gray-500">
            테이블을 클릭하면 이동할 수 있습니다.
        </p>
    </div>

    <div id="main-content">
        <div id="toolbar" class="flex items-center justify-end gap-2 p-3 bg-white border-b border-gray-200">
            <span id="toolbar-left" class="mr-auto text-sm text-gray-600">Powered by Sherman</span>
            
            <!-- 버튼에 새로운 클래스 적용 -->
            <button id="zoom-in" class="toolbar-btn neutral-btn">+</button>
            <button id="zoom-out" class="toolbar-btn neutral-btn">-</button>
            <button id="zoom-reset" class="toolbar-btn neutral-btn">Reset</button>
            <button id="save-coords-btn" class="toolbar-btn primary-btn">좌표 저장</button>
        </div>
        <div id="erd-container" class="relative p-5 bg-gray-50 overflow-auto">
            <div id="pan-container" class="absolute top-0 left-0 w-full h-full transform-origin-top-left cursor-grab">
                <svg id="link-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10"></svg>
                <div id="erd-canvas" class="relative z-20"></div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'http://localhost:3000/api';
        const schemaSelect = document.getElementById('schema-select');
        const erdContainer = document.getElementById('erd-container');
        const panContainer = document.getElementById('pan-container');
        const erdCanvas = document.getElementById('erd-canvas');
        const linkCanvas = document.getElementById('link-canvas');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomResetBtn = document.getElementById('zoom-reset');
        const saveCoordsBtn = document.getElementById('save-coords-btn');

        let allTablesData = {};
        let currentScale = 1;
        const zoomStep = 0.2;

        let isDragging = false;
        let isPanning = false;
        let activeElement = null;
        let initialMouseX, initialMouseY;
        let startPanX, startPanY;
        let currentPanX = 0, currentPanY = 0;

        async function loadSchemas() {
            try {
                const response = await fetch(`${API_BASE_URL}/schemas`);
                if (!response.ok) throw new Error('Network response was not ok.');
                const schemas = await response.json();
                schemas.forEach(schema => {
                    const option = document.createElement('option');
                    option.value = schema;
                    option.textContent = schema;
                    schemaSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load schemas:', error);
                showModal("스키마를 불러오는 데 실패했습니다.");
            }
        }

        async function loadTables(schema) {
            erdCanvas.innerHTML = '';
            linkCanvas.innerHTML = '';
            allTablesData = {};
            currentScale = 1;

            if (!schema) return;

            try {
                const response = await fetch(`${API_BASE_URL}/tables/${schema}`);
                if (!response.ok) throw new Error('Network response was not ok.');
                const tables = await response.json();

                // Fetch columns for all tables concurrently
                const tablePromises = tables.map(table =>
                    fetch(`${API_BASE_URL}/columns/${schema}/${table}`)
                        .then(res => {
                            if (!res.ok) throw new Error(`Failed to load columns for table: ${table}`);
                            return res.json();
                        })
                        .then(columns => {
                            allTablesData[table] = {
                                name: table,
                                columns: columns,
                                position: { x: 0, y: 0 },
                                dimensions: { width: 0, height: 0 }
                            };
                        })
                );

                await Promise.all(tablePromises);
                drawAllTablesAndLinks(schema);

            } catch (error) {
                console.error('Failed to load tables:', error);
                showModal("테이블을 불러오는 데 실패했습니다.");
            }
        }

        function drawAllTablesAndLinks(schema) {
            erdCanvas.innerHTML = '';
            linkCanvas.innerHTML = '';

            const tables = Object.keys(allTablesData);
            
            const horizontalSpacing = 450;
            const verticalSpacing = 300;
            const tablesPerRow = 5;

            const savedPositions = JSON.parse(localStorage.getItem(`erd-coords-${schema}`)) || {};

            tables.forEach((tableName, index) => {
                const tableData = allTablesData[tableName];
                const tableBox = document.createElement('div');
                tableBox.classList.add('table-box');
                tableBox.id = `table-${tableName}`;
                
                let xPos, yPos;
                if (savedPositions[tableName]) {
                    xPos = savedPositions[tableName].x;
                    yPos = savedPositions[tableName].y;
                } else {
                    const row = Math.floor(index / tablesPerRow);
                    const col = index % tablesPerRow;
                    xPos = col * horizontalSpacing + 50;
                    yPos = row * verticalSpacing + 50;
                }

                tableData.position = { x: xPos, y: yPos };
                tableBox.style.left = `${xPos}px`;
                tableBox.style.top = `${yPos}px`;
                tableBox.style.transform = `scale(1)`;

                const tableHeader = document.createElement('h4');
                tableHeader.textContent = tableName;
                tableBox.appendChild(tableHeader);

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = '<th>컬럼</th><th>코멘트</th><th>데이터 타입</th><th>Null 허용</th>';
                thead.appendChild(headerRow);
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                tableData.columns.forEach(col => {
                    const colRow = document.createElement('tr');
                    
                    const dataType = `${col.type}${col.size ? `(${col.size})` : ''}`;
                    
                    let sPK = col.is_primary_key === 'true' ? '(pk)' : '';
                    let sFK = col.is_foreign_key === 'true' ? '(fk)' : ''; 
                    
                    const columnName = `${col.name} ${sPK} ${sFK}`.trim();

                    colRow.innerHTML = `<td>${columnName}</td><td>${col.comment || ''}</td><td>${dataType}</td><td>${col.is_nullable}</td>`;
                    if (col.is_primary_key === 'true') {
                        colRow.classList.add('pk-row');
                    } else if (col.is_foreign_key === 'true') {
                        colRow.classList.add('fk-row');
                    }
                    tbody.appendChild(colRow);
                });
                table.appendChild(tbody);
                
                tableBox.appendChild(table);

                tableBox.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isDragging = true;
                    activeElement = tableBox;
                    initialMouseX = e.clientX - tableData.position.x;
                    initialMouseY = e.clientY - tableData.position.y;
                    activeElement.style.cursor = 'grabbing';
                });
                
                erdCanvas.appendChild(tableBox);

                // Wait for the element to be rendered to get correct dimensions
                setTimeout(() => {
                    tableData.dimensions.width = tableBox.offsetWidth;
                    tableData.dimensions.height = tableBox.offsetHeight;
                    drawLinks(); // Redraw links after all tables are positioned
                }, 0);
            });
            adjustCanvasSize();
            drawLinks();
        }

        function adjustCanvasSize() {
            let maxRight = 0;
            let maxBottom = 0;

            for (const tableName in allTablesData) {
                const tableData = allTablesData[tableName];
                const right = tableData.position.x + tableData.dimensions.width;
                const bottom = tableData.position.y + tableData.dimensions.height;
                maxRight = Math.max(maxRight, right);
                maxBottom = Math.max(maxBottom, bottom);
            }
            
            // Set canvas size based on content, with a minimum size of the container
            const minWidth = erdContainer.clientWidth - 40;
            const minHeight = erdContainer.clientHeight - 40;
            
            erdCanvas.style.width = `${Math.max(minWidth, maxRight + 100)}px`;
            erdCanvas.style.height = `${Math.max(minHeight, maxBottom + 100)}px`;
            
            linkCanvas.style.width = erdCanvas.style.width;
            linkCanvas.style.height = erdCanvas.style.height;
        }

        function drawLinks() {
            linkCanvas.innerHTML = '';
            const tables = Object.values(allTablesData);

            const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            path.setAttribute('fill', '#888');
            marker.appendChild(path);
            linkCanvas.appendChild(marker);

            tables.forEach(table => {
                const fkColumns = table.columns.filter(col => col.is_foreign_key === 'true');
                
                fkColumns.forEach(fkCol => {
                    const fkTable = allTablesData[fkCol.referenced_table];
                    if (!fkTable) return;

                    const startTable = allTablesData[table.name];
                    const endTable = allTablesData[fkTable.name];

                    const startPos = getConnectorPoint(startTable, endTable);
                    const endPos = getConnectorPoint(endTable, startTable);
                    
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', startPos.x);
                    line.setAttribute('y1', startPos.y);
                    line.setAttribute('x2', endPos.x);
                    line.setAttribute('y2', endPos.y);
                    line.setAttribute('stroke', '#888');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                    
                    linkCanvas.appendChild(line);
                });
            });
        }

        function getConnectorPoint(table1, table2) {
            const x1 = table1.position.x + table1.dimensions.width / 2;
            const y1 = table1.position.y + table1.dimensions.height / 2;
            const w1 = table1.dimensions.width;
            const h1 = table1.dimensions.height;

            const x2 = table2.position.x + table2.dimensions.width / 2;
            const y2 = table2.position.y + table2.dimensions.height / 2;
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += 2 * Math.PI;
            
            let point = {};
            const side = Math.abs(Math.tan(angle));
            
            // Determine intersection point on the rectangle boundary
            if (side * w1 < h1) {
                // Intersects a vertical side
                point.x = x1 + Math.sign(dx) * w1 / 2;
                point.y = y1 + Math.sign(dx) * w1 / 2 * side;
            } else {
                // Intersects a horizontal side
                point.x = x1 + Math.sign(dy) * h1 / 2 / side;
                point.y = y1 + Math.sign(dy) * h1 / 2;
            }

            return point;
        }

        function updateZoom() {
            panContainer.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentScale})`;
            drawLinks();
        }

        function zoomIn() {
            currentScale += zoomStep;
            updateZoom();
        }

        function zoomOut() {
            if (currentScale > zoomStep) {
                currentScale -= zoomStep;
                updateZoom();
            }
        }

        function zoomReset() {
            currentScale = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateZoom();
        }

        function saveTablePositions() {
            const currentSchema = schemaSelect.value;
            if (!currentSchema) {
                showModal("저장할 스키마를 선택해주세요.");
                return;
            }
            
            const positionsToSave = {};
            for (const tableName in allTablesData) {
                positionsToSave[tableName] = {
                    x: allTablesData[tableName].position.x,
                    y: allTablesData[tableName].position.y
                };
            }
            
            localStorage.setItem(`erd-coords-${currentSchema}`, JSON.stringify(positionsToSave));
            showModal("테이블 위치가 성공적으로 저장되었습니다!");
        }

        // Custom modal UI instead of alert()
        function showModal(message) {
            const modal = document.createElement('div');
            modal.classList.add('modal');
            modal.textContent = message;

            document.body.appendChild(modal);
            
            setTimeout(() => {
                modal.classList.add('fadeout');
                modal.addEventListener('animationend', () => modal.remove());
            }, 2000);
        }

        // Event listeners
        zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        zoomResetBtn.addEventListener('click', zoomReset);
        saveCoordsBtn.addEventListener('click', saveTablePositions);
        
        erdContainer.addEventListener('mousedown', (e) => {
            // Check if the click is on a table or the background
            if (e.target.closest('.table-box')) {
                isDragging = true;
                activeElement = e.target.closest('.table-box');
                const tableData = allTablesData[activeElement.id.replace('table-', '')];
                initialMouseX = e.clientX - tableData.position.x;
                initialMouseY = e.clientY - tableData.position.y;
                activeElement.style.cursor = 'grabbing';
                e.stopPropagation(); // Prevent canvas panning
            } else {
                isPanning = true;
                startPanX = e.clientX;
                startPanY = e.clientY;
                panContainer.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && activeElement) {
                const tableData = allTablesData[activeElement.id.replace('table-', '')];
                const newX = e.clientX - initialMouseX;
                const newY = e.clientY - initialMouseY;
                
                activeElement.style.left = `${newX}px`;
                activeElement.style.top = `${newY}px`;
                
                tableData.position.x = newX;
                tableData.position.y = newY;
                
                drawLinks();
            } else if (isPanning) {
                const dx = e.clientX - startPanX;
                const dy = e.clientY - startPanY;
                panContainer.style.transform = `translate(${currentPanX + dx}px, ${currentPanY + dy}px) scale(${currentScale})`;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                if (activeElement) {
                    activeElement.style.cursor = 'move';
                    activeElement = null;
                }
            } else if (isPanning) {
                isPanning = false;
                // Update current pan offset
                currentPanX += e.clientX - startPanX;
                currentPanY += e.clientY - startPanY;
                panContainer.style.cursor = 'grab';
            }
        });

        loadSchemas();
    </script>
</body>
</html>
